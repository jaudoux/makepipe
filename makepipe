#! /usr/bin/perl
#
use strict;
use warnings;

=head1 NAME

Makepipe - Create tricky Makefile pipelines from simple YAML configuration files.

=head1 VERSION

version 0.02

=head1 AUTHORS

=over 4

=item Jerome AUDOUX <jaudoux@cpan.org>

=back

=head1 SYNOPSIS

  makepipe command [Arguments]

Available commands:
  
  commands: list the application's commands
      help: display a command's help screen
     brick: display a brick's help
     build: generate a Makefile from a YAML pipelie

=cut

use YAML::XS qw/LoadFile/;
use Pod::Usage;
use File::Temp qw/tempfile tempdir/;
use File::Basename;
#use Getopt::Long;
#use Data::Dumper;

my $bricks_directory = 'bricks/';
my $sub_command = shift @ARGV;
pod2usage(-verbose => 99, -sections => ["VERSION","SYNOPSIS"]) if !defined $sub_command;

if($sub_command eq "help") {

} elsif($sub_command eq "build") {
  my $pipeline_config = shift @ARGV;
  die "You must specify a YAML pipeline file to the build command" unless defined $pipeline_config;
  build($pipeline_config);
} elsif($sub_command eq "brick") {
  my $brick_name = shift @ARGV; 
  if(defined $brick_name) {
    my $brick_file = getBrickFile($brick_name,$bricks_directory);
    my $pod = parseMakefileCommentsToPod($brick_file);
    my ($fh,$filename) = tempfile(); print $fh $pod; close $fh;
    pod2usage(-verbose => 2, -input => $filename);
  } else {
    # Print help message with all available bricks that are presents ins the bricks directory
    opendir(my $dh, $bricks_directory) or die ("Cannot opendir $bricks_directory");
    my @brick_files = sort map {/^(\S+).Makefile$/} grep {/^(\S+).Makefile$/} readdir($dh);
    print STDERR "Specify a brick name to get information about it.\n";
    print STDERR "Availables bricks are:\n\t".join("\n\t",@brick_files)."\n";
  }
} elsif($sub_command eq "diff") {
  my $tarball = shift @ARGV;
  my $dir = tempdir();
  system("tar -xzf $tarball -C $dir");
  system("diff -ur $dir ".dirname($0));
} else {
  print STDERR "Undefined command : $sub_command\n";
  pod2usage(-verbose => 99, -sections => ["VERSION","SYNOPSIS"]) if !defined $sub_command;
}

#print STDERR Dumper($config);
#die;

sub build {
  my $pipeline_config = shift;
  my $config  = LoadFile($pipeline_config);
  print "## THIS FILE HAS BEEN GENERATED BY 'makePipe v0.0' from $pipeline_config\n";

  # Variables definition
  my @all = ();
  my @clean = ();
  my $nb_threads = $config->{config}->{nb_threads};
  $nb_threads = 1 unless defined $nb_threads;
  my $vars = "##############################\n#          VARIABLES         #\n##############################\n\n";
  my $rules = "##############################\n#            RULES           #\n##############################\n\n";

  # Include "CORE" brick
  #unshift(@all,"core");
  #$config->{core}->{brick} = "CORE";

  foreach my $process_name (keys %{$config}) {
    # Next if this is not a hash reference as we expect for a process description
    next if ref($config->{$process_name}) ne "HASH";
    my $brick = $config->{$process_name}->{brick};
    # Next if no brick is defined. We have nothing to do here --> .
    next if !defined $brick;
    my $brick_file = getBrickFile($brick,$bricks_directory);

    # Process loop processes if defined
    # if not we made a loop from the single process
    my $loop = $config->{$process_name}->{loop};
    my $loop_list = $loop->{list};
    my @loop_items;
    if(defined $loop_list) {
      die "List $loop_list not found" if !defined $config->{$loop_list};
      my $i = 0;
      foreach my $item (@{$config->{$loop_list}}) {
        # TODO We should verify that each iteration has a different id!!!
        my $item_name = defined $loop->{id} && defined $item->{$loop->{id}}? $item->{$loop->{id}} : $i;
        push(@loop_items,{name => $process_name."_".$item_name, item => $item, list => $loop_list, item_id => $i});
        $i++;
      }
    } else {
      push(@loop_items,{ name => $process_name, item => undef });
    }

    my $i = 0;
    # Store variable that are common to all process iterations
    my %common_variables;
    my %process_specific_variables;
    # We create a new instance of the brick for as many iterations as we need
    foreach my $process_iteration (@loop_items) {

      # Hold the variables values in a hash table
      my %process_variables;

      # Set the temp "item" list to the current item
      $config->{item} = $process_iteration->{item};

      # Set the temp "this" hash to the current item configuration
      $config->{this} = \%process_variables;

      # Set the temp "item" list to the current item
      #$config->{this} = $config;
      my $process_iteration_name = $process_iteration->{name};

      open (my $fh,$brick_file) or die ("Cannot open $brick_file");
      $vars .= "# Process: $process_iteration_name, constructed from BRICK $brick\n";
      $rules .= "# Process: $process_iteration_name, constructed from BRICK $brick\n";
      my $tmp = ""; # temp buffer used when we do not know if we should place code in vars or rules
      my $prev_statement = \$vars; # Hold a reference to the previously used buffer

      my $append_vars = "";

      # FIXME This is not working yet because we need to place in .SERIAL all the rules
      # that are defined in this process iteration
      #my $execution = $config->{$process_name}->{execution};
      #if(defined $execution && $execution eq 'serial') {
      #  $rules .= ".SERIAL: $process_iteration_name\n";
      #}
      while(<$fh>) {
        # Skip comments
        next if $_ =~ /^#/;
        # Skip blank lines
        next if $_ =~ /^\s*$/;
        if($_ =~ /^ifeq/) {
          $_ = replaceMakefileGenericVariables($_,$process_name,\%common_variables,$process_iteration_name);
          $tmp .= $_;
          next;
        } elsif($_ =~ /^endif/) {
          ${$prev_statement} .= $_;
          next;
        }
        #my($var,$value) = $_ =~ /^%%_(\S+)\s*=\s*(.*)$/;
        # Regex to grep generic variable definitions
        my($var,$op,$value) = $_ =~ /^%%_(\S+)\s*(\+?=)\s*(.*)$/;
        # If this line correspond to a variable assignement
        # we check if a new value is defined in the pipeline config
        if(defined $var && defined $value) {
          #print STDERR "VAR: $var, OP: $op, VALUE: $value\n";
          my $new_val = $config->{$process_name}->{config}->{$var};
          my $replaced_item = 0;
          if(defined $new_val && $op eq '=') {
            # If the value need to be interpreted (ie. with {{..}} formating)
            # TODO We should not directly insert replace the {{..}} formating by
            # the value, but instead include a Makefile $(VARIABLE) that will do
            # it for us.
            $value = replaceItem($new_val,$process_iteration->{list},$process_iteration->{item_id});
            $replaced_item = 1 if $new_val ne $value;
          }

          # if $value is equal to $new_val, then we don't have to define a special
          # variable for this process iteration, we can only do it once
          # FIXME we should double-pass this step in cas a generic variable is define after
          # its first use. In that cas it will not be stored in the %process_variables hash
          # and we do not no what namespace to use "process_name" or "process_iteration_name"

          # FIXME Maybe we should do that at the end??? because it is possible that
          # the value uses a variable that is process-specific and not declared yet
          $value = replaceMakefileGenericVariables($value,$process_name,\%common_variables,$process_iteration_name);

          # Set the value assigned to $var for this process iteration this is
          # the values that will be used by {{this.value}} expressions
          $process_variables{$var} = $value;
          
          # If the value uses a variable that is process specific, then this variable
          # is also process-specific
          $replaced_item = 1 if foundVariable($value,keys %process_specific_variables);

          if($replaced_item) {
            $append_vars .= $tmp.$process_iteration_name."_"."$var $op $value\n";
            $prev_statement = \$append_vars;
            $process_specific_variables{$var} = $process_iteration_name;
          } else {
            $common_variables{$var} = $process_iteration_name if !defined $common_variables{$var};
            $vars .= $tmp.$process_name."_"."$var $op $value\n" if $common_variables{$var} eq $process_iteration_name;
            $prev_statement = \$vars;
          }

          #$value =~ s/%%/$process_iteration_name/g;
          ## We die if a given variable that was supposed to be defined has not been
          # provided by the user
          die ("Undef value for variable $var in process $process_name") if $value =~ /^undef/;
          # Append the variable to the string containing the variables
          #$vars .= $process_iteration_name."_"."$var = $value\n";
        } else {
          # We add the process to the all: target if a PHONY rule exists for this
          # process
          push @all, $process_iteration_name if($_ =~ /^%%:/);
          # Same for clean rule
          push @clean, $process_iteration_name if($_ =~ /^%%_clean:/);
          #$_ =~ s/%%/$process_iteration_name/g;
          $_ = replaceMakefileGenericVariables($_,$process_name,\%common_variables,$process_iteration_name);
          $rules .= $tmp.$_;
          $prev_statement = \$rules;
        } 
        $tmp = ""; # Reset temp buffer
      }
      # Append a new line to variables and rules strings
      $vars .= "\n$append_vars\n";
      $rules .= "\n";

      # Treat summarization process that consists in saving some informations
      # about the current iteration to some datastructure
      foreach my $export_item (@{$loop->{export}}) {
        # TODO We should not export the true value but the variable name and let Makefile
        # do his job
        die "You need to defined a value to be saved with the 'from' key word" unless defined $export_item->{value};
        die "You need to defined a variable to save the value defined with the 'from' key word by using to 'to' key word" unless defined $export_item->{to};
        my $from = replaceVars($export_item->{value},$config);
        setValueToHash($config,$export_item->{to},$from);
      }

      $i++;
    }
  }

  # Print "all:" rule
  print "\nall: ".'$(lastword $(MAKEFILE_LIST))'."\n";
  print "\t".'$(MAKE) -j '."$nb_threads ".join(" ", @all)."\n" if @all;
  print ".PHONY: all\n\n";

  # Print rule to re-generate the makefile if the pipeline has changed
  print '$(lastword $(MAKEFILE_LIST))'.": $pipeline_config\n",
    "\t$0 build ".'$< > $@'."\n\n";


  # Print vars and replace {{..}} expression with correct value
  # we need two pass form .extract() expressions
  print replaceVars(replaceVars($vars,$config),$config);

  # Print rules
  print $rules;

  # print clean target
  print "clean: ".join(" ",map { $_."_clean" } @clean),"\n";

  # TODO add rm
  #print Dumper($config);
}

# return true if one of the variable in argument is find in the string
sub foundVariable {
  my ($string,@variables) = @_;
  foreach my $var (@variables) {
    return 1 if($string =~ $var);
  }
  return 0;
}

# given a string with {{item.X.Y.Z}} expression, replace item
# with the appropriate list element.
sub replaceItem {
  my ($string, $list_name, $id) = @_;
  $string =~ s/{{item\.([^}]*)}}/"{{$list_name.[$id].$1}}"/eg;
  return $string;
}

sub replaceVars {
  my ($string, $config) = @_;
  $string =~ s/{{([^}]*)}}/getValueFromHash($config,$1)/eg;
  return $string;
}

# given a "a.b.c" expression associated to a hash h->{a}->{b}->{c}
# gives the value of the leaf c
sub getValueFromHash {
  my ($h,$keys,$new_value) = @_;
  my @split_key = split /\./, $keys;
  my $last_key = pop @split_key;
  foreach my $k (@split_key) {
    # If key correspond to an array element instead of hash key
    if($k =~ /^\[\d+\]$/) {
      my ($index) = $k =~ /^\[(\d+)\]$/;
      $h = $h->[$index];
    } else {
      $h = $h->{$k};
    }
  }
  if($last_key =~ /extract/) {
    my ($sub_key) = $last_key =~ /^extract\(["\']?([^"\']*)["\']?\)$/;
    my @extracted_values;
    foreach my $it (@{$h}) {
      push @extracted_values, $it->{$sub_key};
    }
    # TODO This shoud not be joined
    return join(" ",@extracted_values);
  }else {
    $h->{$last_key} = $new_value if defined $new_value;
    return $h->{$last_key};
  }
}

# Just an alias subroutines that call the generic "getValueFromHash"
# that can also the the variable
sub setValueToHash {
  getValueFromHash(@_);
}

# Replace Make variable that are constructed like : $(%%_XXX)
# whre XXX is the variable name and %% will be replace by the name of
# the block instanciation
sub replaceMakefileGenericVariables {
  my ($line,$process_name,$process_variables,$process_iteration_name) = @_;
  #print STDERR $line;
  my $replaceSub = sub { my $var_name = shift; defined $process_variables->{$var_name}? return $process_name : return $process_iteration_name; };
  $line =~ s/%%(_?)([^\):]*)/$replaceSub->($2)."$1$2"/eg;
  #print STDERR $line;
  return $line;
}

# Read a Makefile and extract comments that are presents in it to 
# generate a POD documentation
sub parseMakefileCommentsToPod {
  my $makefile = shift;
  open(my $fh, "<", $makefile) or die("Cannot open Makfile: $makefile");
  my $pod = "";
  my $in_list = 0;
  while(<$fh>) {
    # Title comment
    if($_ =~ /^(#+)\s(.*)/) {
      $pod .= "\n=back\n\n" if $in_list;
      if(length($1) > 1) {
        $pod .= "\n=head".(length($1)-1)." $2\n";
      } else {
        $pod .= "\t$2\n";
      }
      $in_list = 0;
    } elsif($_ =~ /^%%_(\S+)\s*=\s*([^\s*#]*)\s*#\s*(.*)/) {
      #$2 =~ s/\s+$//; # trim
      $pod .= "\n=over\n" if !$in_list;
      $pod .= "\n=item B<$1> (Default: I<$2>)\n\n$3\n";
      $in_list = 1;
    }
  }
  $pod .= "\n=back\n\n" if $in_list;
  return $pod."\n=cut\n\n";
}

sub getBrickFile {
  my ($brick,$bricks_directory) = @_;
  my $brick_file = "$bricks_directory/$brick.Makefile";

  if(!-e $brick_file) {
    die "brick $brick not found in bricks directory: $bricks_directory";
  }
  return $brick_file;
}
