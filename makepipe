#! /usr/bin/perl
#
use strict;
use warnings;

=head1 NAME

Makepipe - Create tricky Makefile pipelines from simple YAML configuration files.

=head1 VERSION

version 0.04

=head1 AUTHORS

=over 4

=item Jerome AUDOUX <jaudoux@cpan.org>

=back

=head1 SYNOPSIS

  makepipe command [Arguments]

Available commands:

  * help: display a command's help screen
  * build: yaml: generate a Makefile from a YAML pipeline
  * brick: list all bricks available
  * brick name: display a brick's help
  * init: init a new project with makepipe in current folder
  * update: update makepipe submodule from repository

=cut

use YAML::XS qw/LoadFile Dump/;
use JSON;
use Pod::Usage;
use File::Temp qw/tempfile tempdir/;
use File::Basename;
use Carp;
use File::Spec;
use Getopt::Long;
use Data::Dumper;
use Cwd 'abs_path';

# manage option via '-'
my $verbose = 0;
my $debug = 0;
GetOptions(
	'v|verbose+'	=> \$verbose,
);
$debug = 1 if ($verbose >1);

my $bricks_directory = 'makepipe/bricks';
my @generic_bricks_directories = ($bricks_directory,dirname(abs_path($0))."/$bricks_directory");
my $sub_command = shift @ARGV;
pod2usage(-verbose => 99, -sections => ["VERSION","SYNOPSIS"]) if !defined $sub_command;

if($sub_command eq "help") {

} elsif($sub_command eq "build") {
  my $pipeline_config = shift @ARGV;
  die "You must specify a YAML pipeline file to the build command" unless defined $pipeline_config;
  build($pipeline_config);
} elsif($sub_command eq "brick") {
  my $brick_name = shift @ARGV; 
  if(defined $brick_name) {
    my $brick_file = getBrickFile($brick_name,\@generic_bricks_directories);
    my $pod = parseMakefileCommentsToPod($brick_file);
    my ($fh,$filename) = tempfile(); print $fh $pod; close $fh;
    pod2usage(-verbose => 2, -input => $filename);
  } else {
    # Print help message with all available bricks that are presents ins the bricks directory
    opendir(my $dh, $bricks_directory) or die ("Cannot opendir $bricks_directory");
    my @brick_files = sort map {/^(\S+).Makefile$/} grep {/^(\S+).Makefile$/} readdir($dh);
    print STDERR "Specify a brick name to get information about it.\n";
    print STDERR "Availables bricks are:\n\t".join("\n\t",@brick_files)."\n";
  }
} elsif($sub_command eq "diff") {
  my $tarball = shift @ARGV;
  my $dir = tempdir();
  system("tar -xzf $tarball -C $dir");
  system("diff -ur $dir ".dirname($0));
} else {
  print STDERR "Undefined command : $sub_command\n";
  pod2usage(-verbose => 99, -sections => ["VERSION","SYNOPSIS"]) if !defined $sub_command;
}

#print STDERR Dumper($config);
#die;

sub build {
  my $pipeline_config = shift;
  my $config  = LoadFile($pipeline_config);
  carp Dumper($config) if ($debug);
  my @dependencies = ($pipeline_config);
  print "## THIS FILE HAS BEEN GENERATED BY 'makePipe v0.0' from $pipeline_config\n";
  print "SHELL=bash\n";

  # Variables definition
  my @all = ();
  my @clean = ();
  my $vars = "##############################\n#          VARIABLES         #\n##############################\n\n";
  my $rules = "##############################\n#            RULES           #\n##############################\n\n";

  # Include "CORE" brick
  #unshift(@all,"core");
  #$config->{core}->{brick} = "CORE";
  
  # Special keyword 'makepipe' is used for makepipes configuration
  my $m_config;
  $m_config->{nb_jobs} = 1;
  push @{$m_config->{brick_dirs}}, @generic_bricks_directories;
  loadMakepipeConfig($m_config,$config,\@dependencies);
  carp Dumper($m_config) if ($debug);
  carp "config:", Dumper($config) if ($debug);

  # load 'all targets if thet ared if defined by user
  @all = split(" ",$m_config->{all_targets}) if defined $m_config->{all_targets};

  foreach my $process_name (keys %{$config}) {
	# print to follow process
	carp "process name in use: $process_name" if ($verbose);
    # Next if this is not a hash reference as we expect for a process description
    next if ref($config->{$process_name}) ne "HASH";
    my $brick = $config->{$process_name}->{brick};
    # Next if no brick is defined. We have nothing to do here --> .
    next if !defined $brick;
    my $brick_file = getBrickFile($brick,$m_config->{brick_dirs});
    push @dependencies, $brick_file;

    # Process loop processes if defined
    # if not we made a loop from the single process
    my $loop = $config->{$process_name}->{loop};
    my $loop_list = $loop->{list};
    my $loop_filter = $loop->{filter};
    my %loop_items;
    if(defined $loop_list) {
      die "List $loop_list not found" if !defined $config->{$loop_list};
      my $i = 0;
      foreach my $item (@{$config->{$loop_list}}) {
        if(defined $loop_filter) {
          my $filter_value = getValueFromHash($item,$loop_filter);
          if(!defined $filter_value) {
            $i++;
            next;
          }
        }
        my $item_name = defined $loop->{id} && defined $item->{$loop->{id}}? $item->{$loop->{id}} : $i;
        my $process_iteration_name = $process_name."_".$item_name;
        if(defined $loop_items{$process_iteration_name}) {
          die "Two items with the same name ($item_name) in process $process_name."
        }
        $loop_items{$process_iteration_name} = {item => $item, list => $loop_list, item_id => $i};
        $i++;
      }
      # Add master rules to make all iteration process and to clean all iteration files
      $rules .= "# Master process: $process_name\n";
      $rules .= "$process_name: ".join(" ", map { $_ } keys %loop_items)."\n";
      $rules .= "$process_name"."_clean: ".join(" ", map { $_."_clean" } keys %loop_items)."\n\n";
    } else {
      $loop_items{$process_name} = {item => undef};
    }

    my $i = 0;
    # Store variable that are common to all process iterations
    my %common_variables;
    my %process_specific_variables;
    # We create a new instance of the brick for as many iterations as we need
    foreach my $process_iteration_name (keys %loop_items) {

      # Hold the variables values in a hash table
      my %process_variables;

      # Set the temp "item" list to the current item
      my $process_iteration = $loop_items{$process_iteration_name};

      # Set the temp "item" list to the current item
      $config->{item} = $process_iteration->{item};

      # Set the temp "this" hash to the current item configuration
      $config->{this} = \%process_variables;

      open (my $fh,$brick_file) or die ("Cannot open $brick_file");
      $vars .= "# Process: $process_iteration_name, constructed from BRICK $brick\n";
      $rules .= "# Process: $process_iteration_name, constructed from BRICK $brick\n";
      my $tmp = ""; # temp buffer used when we do not know if we should place code in vars or rules
      my $prev_statement = \$vars; # Hold a reference to the previously used buffer

      my $append_vars = "";

      # FIXME This is not working yet because we need to place in .SERIAL all the rules
      # that are defined in this process iteration
      #my $execution = $config->{$process_name}->{execution};
      #if(defined $execution && $execution eq 'serial') {
      #  $rules .= ".SERIAL: $process_iteration_name\n";
      #}
      while(<$fh>) {
        # Skip comments
        next if $_ =~ /^#/;
        # Skip blank lines
        next if $_ =~ /^\s*$/;
        if($_ =~ /^ifeq|else|ifneq/) {
          $_ = replaceMakefileGenericVariables($_,$process_name,\%common_variables,$process_iteration_name);
          $tmp .= $_;
          next;
        } elsif($_ =~ /^endif/) {
          ${$prev_statement} .= $_;
          next;
        }
        #my($var,$value) = $_ =~ /^%%_(\S+)\s*=\s*(.*)$/;
        # Remove the comments at the end of the line
        $_ =~ s/#.*$//g;
        # Regex to grep generic variable definitions
        my($var,$op,$value) = $_ =~ /\s*%%_(\S+)\s*(\+?=)\s*(.*)$/;
        # If this line correspond to a variable assignement
        # we check if a new value is defined in the pipeline config
        if(defined $var && defined $value) {
          my $new_val = $config->{$process_name}->{config}->{$var};
          my $replaced_item = 0;
          if(defined $new_val && $op eq '=') {
            # If the value need to be interpreted (ie. with {{..}} formating)
            # TODO We should not directly insert replace the {{..}} formating by
            # the value, but instead include a Makefile $(VARIABLE) that will do
            # it for us.
            # TODO we could remove replaceItem method and do the same thing that we 
            # do for "this" instructions
            $value = replaceItem($new_val,$process_iteration->{list},$process_iteration->{item_id});
            $replaced_item = 1 if $new_val ne $value || $value =~ /{{this\./;
          }

          # if $value is equal to $new_val, then we don't have to define a special
          # variable for this process iteration, we can only do it once
          # FIXME we should double-pass this step in cas a generic variable is define after
          # its first use. In that cas it will not be stored in the %process_variables hash
          # and we do not no what namespace to use "process_name" or "process_iteration_name"

          # FIXME Maybe we should do that at the end??? because it is possible that
          # the value uses a variable that is process-specific and not declared yet
          $value = replaceMakefileGenericVariables($value,$process_name,\%common_variables,$process_iteration_name);

          # Set the value assigned to $var for this process iteration this is
          # the values that will be used by {{this.value}} expressions
          $process_variables{$var} = '$('.$process_iteration_name."_".$var.')';
          
          # If the value uses a variable that is process specific, then this variable
          # is also process-specific
          #$replaced_item = 1 if foundVariable($value,keys %process_specific_variables);
          $replaced_item = 1;

          if($replaced_item) {
            $append_vars .= $tmp.$process_iteration_name."_"."$var $op $value\n";
            $prev_statement = \$append_vars;
            $process_specific_variables{$var} = $process_iteration_name;
          } else {
            $common_variables{$var} = $process_iteration_name if !defined $common_variables{$var};
            if($common_variables{$var} eq $process_iteration_name) {
              $vars .= $tmp.$process_name."_"."$var $op $value\n";
              $prev_statement = \$vars;
            } else {
              $prev_statement = undef;
            }
          }

          #$value =~ s/%%/$process_iteration_name/g;
          ## We die if a given variable that was supposed to be defined has not been
          # provided by the user
          die ("Undef value for variable $var in process $process_name") if $value =~ /^undef/;
          # Append the variable to the string containing the variables
          #$vars .= $process_iteration_name."_"."$var = $value\n";
        } else {
          # We add the process to the all: target if a PHONY rule exists for this
          # process
          push @all, $process_iteration_name if $_ =~ /^%%:/ && !defined $m_config->{all_targets};
          # Same for clean rule
          push @clean, $process_iteration_name if($_ =~ /^%%_clean:/);
          #$_ =~ s/%%/$process_iteration_name/g;
          $_ = replaceMakefileGenericVariables($_,$process_name,\%common_variables,$process_iteration_name);
          $rules .= $tmp.$_;
          $prev_statement = \$rules;
        } 
        $tmp = ""; # Reset temp buffer
      }
      # Append a new line to variables and rules strings
      $vars .= "\n$append_vars\n";
      $rules .= "\n";

      # Replace {{this.}} variables before we go out of the scope of this process iteration
      $vars = replaceVars($vars,$config,"this");

      # Treat summarization process that consists in saving some informations
      # about the current iteration to some datastructure
      foreach my $export_item (@{$loop->{export}}, @{$config->{$process_name}->{export}}) {
        die "You need to defined a value to be saved with the 'from' key word" unless defined $export_item->{value};
        die "You need to defined a variable to save the value defined with the 'from' key word by using to 'to' key word" unless defined $export_item->{to};
        # Remove Makefile comments
        #my $from = replaceVars($export_item->{value},$config);
        my $from = replaceItem(replaceVars($export_item->{value},$config,"this"),$process_iteration->{list},$process_iteration->{item_id});
        my $to   = replaceItemSimple($export_item->{to},$process_iteration->{list},$process_iteration->{item_id});
        #removeMakefileComments(replaceVars($export_item->{value},$config));
        if(defined $export_item->{action} && $export_item->{action} eq "push") {
          if(!defined getValueFromHash($config,$to)) {
            setValueToHash($config,$to,[$from]);
          } else {
            push @{getValueFromHash($config,$to)},$from;
          }
        }elsif(defined $export_item->{action} && $export_item->{action} eq "append") {
          my $current_value = getValueFromHash($config,$to);
          $current_value .= ' '.$from;
          setValueToHash($config,$to,$current_value);
        } else {
          setValueToHash($config,$to,$from);
        }
      }

      $i++;
    }
  }

  # Print "all:" rule
  print "\nall: ".'$(lastword $(MAKEFILE_LIST))'."\n";
  print "\t".'$(MAKE) -j '."$m_config->{nb_jobs} ".join(" ", @all)."\n" if @all;
  print ".PHONY: all\n\n";

  # Print rule to re-generate the makefile if the pipeline has changed
  print '$(lastword $(MAKEFILE_LIST))'.": ".join(" ",@dependencies)."\n",
    "\t$0 build ".'$< > $@'."\n\n";


  # Print vars and replace {{..}} expression with correct value
  # we need two pass form .extract() expressions
  #print replaceVars(replaceVars($vars,$config),$config);
  #print replaceVars($config,$config,"softwares");
  print replaceVars($vars,$config);

  # Print rules
  print $rules;

  # print clean target
  print "clean: ".join(" ",map { $_."_clean" } @clean),"\n";

  # TODO add rm
  #print Dumper($config);
}

sub loadMakepipeConfig {
  my ($m_config,$config,$dependencies) = @_;
  if(defined $config->{makepipe}) {
    my $l_config    = $config->{makepipe};
    my $includes    = $l_config->{includes};
    my $brick_dirs  = $l_config->{brick_dirs};

    # Set parameters
    $m_config->{nb_jobs} = $l_config->{nb_jobs} if defined $l_config->{nb_jobs};
    $m_config->{all_targets} = $l_config->{all_targets} if defined $l_config->{all_targets};

    # Load brick dirs
    if(defined $brick_dirs) {
      croak "makepipe 'brick_dirs' should be an array" unless ref($brick_dirs) eq "ARRAY";
      map { push @{$m_config->{brick_dirs}}, $_ } @{$brick_dirs};
    }

    # Load includes
    if(defined $includes) {
      croak "makepipe includes should be an array" unless ref($includes) eq "ARRAY";
      foreach my $inc (@{$includes}) {
        my $inc_config = LoadFile($inc);
        push @{$dependencies}, $inc;
        loadMakepipeConfig($m_config,$inc_config,$dependencies);
        delete $inc_config->{makepipe};
        updateConfigEntry($config,$inc_config);
      }
    }
  }
  return $m_config;
}

sub updateConfigEntry {
  my ($a,$b) = @_;
  if(ref($a) eq 'HASH' && ref($b) eq 'HASH') {
    foreach my $k (keys %{$b}) {
      if(defined $a->{$k}) {
        updateConfigEntry($a->{$k},$b->{$k});
      } else {
        $a->{$k} = $b->{$k};
      }
    }
  }
}

# return true if one of the variable in argument is find in the string
sub foundVariable {
  my ($string,@variables) = @_;
  foreach my $var (@variables) {
    return 1 if($string =~ $var);
  }
  return 0;
}

# given a string with {{item.X.Y.Z}} expression, replace item
# with the appropriate list element.
sub replaceItem {
  my ($string, $list_name, $id) = @_;
  if(ref($string) eq 'HASH') {
    my %new_hash;
    foreach my $k (keys %{$string}) {
      $new_hash{$k} = replaceItem($string->{$k},$list_name,$id);
    }
    return \%new_hash;
  }elsif(ref($string) eq 'ARRAY') {
    my @new_array;
    for(my $i = 0; $i < @{$string}; $i++) {
      $new_array[$i] = replaceItem($string->[$i],$list_name,$id);
    }
    return \@new_array;
  }else {
    $string =~ s/{{item/"{{$list_name.[$id]"/eg;
  }
  return $string;
}

sub replaceItemSimple {
  my ($string, $list_name, $id) = @_;
  $string =~ s/^item/"$list_name.[$id]"/eg;
  return $string;
}

sub replaceVars {
  my ($string, $config,$prefix) = @_;
  # TODO Should we do a copy?
  if(ref($string) eq 'HASH') {
    my %new_hash;
    foreach my $k (keys %{$string}) {
      $new_hash{$k} = replaceVars($string->{$k},$config,$prefix);
    }
    return \%new_hash;
  }elsif(ref($string) eq 'ARRAY') {
    my @new_array;
    for(my $i = 0; $i < @{$string}; $i++) {
      $new_array[$i] = replaceVars($string->[$i],$config,$prefix);
    }
    return \@new_array;
  }
  $prefix = "" unless defined $prefix;
  # First we need to handle the $if$,$else$ statements
  my $f = sub {
    my($condition,$if_statement,$else_statement) = @_;
    if(defined getValueFromHash($config,$condition)) {
      return $if_statement;
    } else {
      if(defined $else_statement) {
        return $else_statement;
      } else {
        return "";
      }
    }
  };
  $string =~ s/\$if\((.*)\)\$(.*)\$(?:else\$(.*)\$)?endif\$/$f->($1,$2,$3)/ge;
  # FIXME Add a warning if the value does not exists
  my $new_string = $string =~ s/{{($prefix[^}]*)}}/getValueFromHash($config,$1)/egr;
  $new_string = replaceVars($new_string,$config,$prefix) if($new_string ne $string); 
  return $new_string;
}

# given a "a.b.c" expression associated to a hash h->{a}->{b}->{c}
# gives the value of the leaf c
sub getValueFromHash {
  my ($h,$keys,$new_value) = @_;
  # TODO Change regex
  #my @split_key = split m/\.(?![^()]*\))/, $keys;
  my @split_key;
  while($keys =~ /([^\.\(]+(?:\(.*\))?)/g) {
      push @split_key, $1;
  }
  my $last_key = pop @split_key;
  foreach my $k (@split_key) {
    # If key correspond to an array element instead of hash key
    $h = getNextValue($h,$k);
  }
  if($last_key =~ /extract/) {
    my ($args)  = $last_key =~ /^extract\((.*)\)$/;
    my @args  = split(',',$args);
    my @extracted_values;
    my $sep = " ";
    my @extract_keys;
    my $inside_sep = ",";
    foreach my $arg (@args) {
      my ($k, $v) = split("=",$arg);
      if(defined $v) {
        if($k eq 'sep') {
          $sep = removeQuotes($v);
        } elsif($k eq 'inside_sep') {
          $inside_sep = removeQuotes($v);
        }
      } else {
        push @extract_keys, removeQuotes($arg);
      }
    }
    if(@extract_keys) {
      foreach my $it (@{$h}) {
        my @local_values;
        foreach my $k (@extract_keys) {
          push @local_values, getValueFromHash($it,$k);
        }
        push @extracted_values, join($inside_sep,@local_values);
        #push @extracted_values, $it->{$sub_key};
      }
    } else {
      foreach my $it (@{$h}) {
        push @extracted_values, $it;
      }
    }
    # TODO This shoud not be joined
    return join($sep,@extracted_values);
  }elsif($last_key =~ /equal/) {
    my ($value) = $last_key =~ /^equal\((.*)\)$/;
    $value = removeQuotes($value);
    return $h eq $value? $value : undef;
  }elsif($last_key =~ /yaml/) {
    return Dump($h);
  }elsif($last_key =~ /json/) {
    return encode_json $h;
  }else {
    return getNextValue($h,$last_key,$new_value);
  }
}

# Given a collection (hash or array) and a key return the next
# value.
# for example if k=[1], getNextValue will return $h->[1]
# if k=test, getNextValue will return $h->{test}
# if a value is provided in supplement, the value will also be set
# before being returned
sub getNextValue {
  my($h,$k,$v) = @_;
  if($k =~ /^\[\d+\]$/) {
    my ($index) = $k =~ /^\[(\d+)\]$/;
    $h->[$index] = $v if defined $v;
    return $h->[$index];
  } else {
    $h->{$k} = $v if defined $v;
    print STDERR "value $k not found\n" if !defined $h->{$k};
    return $h->{$k};
  }
}

# Just an alias subroutines that call the generic "getValueFromHash"
# that can also the the variable
sub setValueToHash {
  return getValueFromHash(@_);
}

# Replace Make variable that are constructed like : $(%%_XXX)
# whre XXX is the variable name and %% will be replace by the name of
# the block instanciation
sub replaceMakefileGenericVariables {
  my ($line,$process_name,$process_variables,$process_iteration_name) = @_;
  my $replaceSub = sub { my $var_name = shift; defined $process_variables->{$var_name}? return $process_name : return $process_iteration_name; };
  $line =~ s/%%(_?)([^\):]*)/$replaceSub->($2)."$1$2"/eg;
  return $line;
}

# Read a Makefile and extract comments that are presents in it to 
# generate a POD documentation
sub parseMakefileCommentsToPod {
  my $makefile = shift;
  open(my $fh, "<", $makefile) or die("Cannot open Makfile: $makefile");
  my $pod = "";
  my $in_list = 0;
  while(<$fh>) {
    # Title comment
    if($_ =~ /^(#+)\s(.*)/) {
      $pod .= "\n=back\n\n" if $in_list;
      if(length($1) > 1) {
        $pod .= "\n=head".(length($1)-1)." $2\n";
      } else {
        $pod .= "\t$2\n";
      }
      $in_list = 0;
    } elsif($_ =~ /^%%_(\S+)\s*=\s*([^#]*)\s*#\s*(.*)/) {
      #$2 =~ s/\s+$//; # trim
      $pod .= "\n=over\n" if !$in_list;
      $pod .= "\n=item B<$1> (Default: I<$2>)\n\n$3\n";
      $in_list = 1;
    }
  }
  $pod .= "\n=back\n\n" if $in_list;
  return $pod."\n=cut\n\n";
}

sub getBrickFile {
  my ($brick,$brick_dirs) = @_;

  foreach my $dir (@{$brick_dirs}) {
    my $brick_file = File::Spec->catfile($dir,"$brick.Makefile");
    return $brick_file if (-e $brick_file);
  }

  die "brick $brick not found in brick directories: ".join(",",@{$brick_dirs});
}

sub removeQuotes {
  my $v = shift;
  my ($unquoted_v) = $v =~ /^["\']?([^"\']*)["\']?$/;
  #my ($unquoted_v) = $v =~ /^["\']?(.*)["\']?$/;
  return $unquoted_v;
}

sub removeMakefileComments {
  my $v = shift;
  $v =~ s/([^#]*)(#?.*)/$1/;
  return $v;
}
