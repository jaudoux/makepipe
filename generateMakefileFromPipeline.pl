#! /usr/bin/perl
#
use strict;
use warnings;

use YAML::XS qw/LoadFile/;
use Data::Dumper;

my $pipeline_config = shift @ARGV;
my $bricks_directory = 'bricks/';

my $config  = LoadFile($pipeline_config);

print STDERR Dumper($config);
#die;

print "## THIS FILE HAS BEEN GENERATED BY 'makePipe v0.0' from $pipeline_config\n";

# Variables definition
my @all = ();
my @clean = ();
my $vars = "##############################\n#          VARIABLES         #\n##############################\n\n";
my $rules = "##############################\n#            RULES           #\n##############################\n\n";

# Include "CORE" brick
#unshift(@all,"core");
$config->{core}->{brick} = "CORE";

foreach my $process (keys %{$config}) {
  # Next if this is not a hash reference as we expect for a process description
  next if ref($config->{$process}) ne "HASH";
  my $brick = $config->{$process}->{brick};
  # Next if no brick is defined. We have nothing to do here --> .
  next if !defined $brick;
  my $brick_file = "$bricks_directory/$brick.Makefile";

  if(!-e $brick_file) {
    print STDERR "brick $brick not found in bricks directory: $bricks_directory\n";
    next;
  }

  # Process loop processes if defined
  # if not we made a loop from the single process
  my $loop = $config->{$process}->{loop};
  my $loop_list = $loop->{list};
  my @loop_items;
  if(defined $loop_list) {
    die "List $loop_list not found" if !defined $config->{$loop_list};
    my $i = 0;
    foreach my $item (@{$config->{$loop_list}}) {
      push(@loop_items,{name => $process."_".$i, item => $item, list => $loop_list, item_id => $i});
      $i++;
    }
  } else {
    push(@loop_items,{ name => $process, item => undef });
  }

  # We create a new instance of the brick for as many iterations as we need
  foreach my $process_iteration (@loop_items) {

    # Hold the variables values in a hash table
    my %process_variables;

    # Set the temp "item" list to the current item
    $config->{item} = $process_iteration->{item};

    # Set the temp "this" hash to the current item configuration
    $config->{this} = \%process_variables;

    # Set the temp "item" list to the current item
    #$config->{this} = $config;
    my $process_name = $process_iteration->{name};

    open (my $fh,$brick_file) or die ("Cannot open $brick_file");
    $vars .= "# Process: $process_name, constructed from BRICK $brick\n";
    $rules .= "# Process: $process_name, constructed from BRICK $brick\n";
    while(<$fh>) {
      # Skip comments
      next if $_ =~ /^#/;
      # Skip blank lines
      next if $_ =~ /^\s*$/;
      #my($var,$value) = $_ =~ /^%%_(\S+)\s*=\s*(.*)$/;
      my($var,$value) = $_ =~ /^%%_(\S+)\s*=\s*(.*)$/;
      # If this line correspond to a variable assignement
      # we check if a new value is defined in the pipeline config
      if(defined $var && defined $value) {
        my $new_val = $config->{$process}->{config}->{$var};
        if(defined $new_val) {
          # If the value need to be interpreted (ie. with {{..}} formating)
          # TODO We should not directly insert replace the {{..}} formating by
          # the value, but instead include a Makefile $(VARIABLE) that will do
          # it for us.
          #$new_val = replaceVars($new_val,$config);
          $new_val = replaceItem($new_val,$process_iteration->{list},$process_iteration->{item_id});
          $value = $new_val;
        }
        # Set the value assigned to $var for this process iteration this is
        # the values that will be used by {{this.value}} expressions
        $process_variables{$var} = $value;
        # FIXME this should not be used anymore, no variable should be
        # interpreted by Makefiles
        $value =~ s/%%/$process_name/g;
        ## We die if a given variable that was supposed to be defined has not been
        # provided by the user
        die ("Undef value for variable $var in process $process") if $value eq 'undef';
        $vars .= $process_name."_"."$var = $value\n";
      } else {
        # We add the process to the all: target if a PHONY rule exists for this
        # process
        push @all, $process_name if($_ =~ /^%%:/);
        # Same for clean rule
        push @clean, $process_name if($_ =~ /^%%_clean:/);
        $_ =~ s/%%/$process_name/g;
        $rules .= $_;
      } 
    }
    # Append a new line to variables and rules strings
    $vars .= "\n";
    $rules .= "\n";

    # Treat summarization process that consists in saving some informations
    # about the current iteration to some datastructure
    foreach my $record_item (@{$loop->{record}}) {
      # TODO We should not record the true value but the variable name and let Makefile
      # do his job
      die "You need to defined a value to be saved with the 'from' key word" unless defined $record_item->{value};
      die "You need to defined a variable to save the value defined with the 'from' key word by using to 'to' key word" unless defined $record_item->{to};
      my $from = replaceVars($record_item->{value},$config);
      setValueToHash($config,$record_item->{to},$from);
    }
  }
}

# Print "all:" rule
print "\nall: ".join(" ", @all)."\n.PHONY: all\n\n";

# Print vars and replace {{..}} expression with correct value
# we need two pass form .extract() expressions
print replaceVars(replaceVars($vars,$config),$config);

# Print rules
print $rules;

# print clean target
print "clean: ".join(" ",map { $_."_clean" } @clean),"\n";


# TODO add rm

#print Dumper($config);

# given a string with {{item.X.Y.Z}} expression, replace item
# with the appropriate list element.
sub replaceItem {
  my ($string, $list_name, $id) = @_;
  print STDERR "Before replaceItem: $string\n";
  $string =~ s/{{item\.([^}]*)}}/"{{$list_name.[$id].$1}}"/eg;
  print STDERR "After replaceItem: $string\n";
  return $string;
}

sub replaceVars {
  my ($string, $config) = @_;
  #my @patterns = $string =~ /{{([^}]*)}}/;
  $string =~ s/{{([^}]*)}}/getValueFromHash($config,$1)/eg;
  return $string;
}

# given a "a.b.c" expression associated to a hash h->{a}->{b}->{c}
# gives the value of the leaf c
sub getValueFromHash {
  my ($h,$keys,$new_value) = @_;
  my @split_key = split /\./, $keys;
  my $last_key = pop @split_key;
  foreach my $k (@split_key) {
    # If key correspond to an array element instead of hash key
    if($k =~ /^\[\d+\]$/) {
      print STDERR "TOTO\n";
      my ($index) = $k =~ /^\[(\d+)\]$/;
      $h = $h->[$index];
    } else {
      $h = $h->{$k};
    }
  }
  if($last_key =~ /extract/) {
    my ($sub_key) = $last_key =~ /^extract\(["\']?([^"\']*)["\']?\)$/;
    my @extracted_values;
    foreach my $it (@{$h}) {
      push @extracted_values, $it->{$sub_key};
    }
    # TODO This shoud not be joined
    return join(" ",@extracted_values);
  }else {
    $h->{$last_key} = $new_value if defined $new_value;
    return $h->{$last_key};
  }
}

# Just an alias subroutines that call the generic "getValueFromHash"
# that can also the the variable
sub setValueToHash {
  getValueFromHash(@_);
}

